

## 6.1函数基础

1. 当方法内部定义了和外部变量同名的变量时两个变量会同同时存在,且在作用域内局部变量优先级高于外部变量

一个方法可以被多次声明但是只能有一个定义.

## 6.2参数传递

- 用实参初始化形参变量时会忽略掉顶层const.当传递给一个const形参以const实参和非const形参都是可以的.

- 可以使用字面值初始化const引用变量.

- 当将数数组传递给方法时会被自动转化为指向数组首地址的指正.

- 传递数组长度的方法
  - 使用标志位(c风格字符串)
  - 标准库规范(传递开始和结束位置的指针)
  - 显示传递数组的大小
- main 处理命令行选项
- 当函数的参数数量未知,但是类型相同时可以使用初始化列表的方式进行参数传递initializer_list是一种标准库类型.

## 6.3函数返回值

- 不要返回方法体内定义的临时变量的引用或者指针.

- 返回引用的函数返回左值,其他则为右值.

- 当返回的对象可以使用初始化列表{}进行初始化时我们可以直接返回用{}起来的变量.

- 数组无法被拷贝,因此无法返回数组,只能返回数组的引用或者指针

- 使用位置返回值类型,当返回值的类型过于复杂时我们可以使用这种方式提升代码的可读性

  - ```cpp
    auto func(int i)->int(*)[10];//返回一个指针指向一个有10个值的数组.
    ```

- 当我们已经定义了一个想要返回类型一样的变量时可以采用decltype的方式获取返回值的类型.

  - ```cpp
    int *a[10];
    decltype(a) *arrPtr(int i );
    ```

## 6.4 函数重载

- 一个拥有顶层const的形参和没有顶层const的形参无法进行区分并进行重载函数的操作
- 底层const可以区分两个形参当形参是引用或者指针时可以const用于区分变量类型并进行重载,因为此时的const 底层const
- const_cast在重载函数的场景中最有用.
- 当函数存在重载时编译器会根据实参的类型决定调用的函数, 最佳匹配,无匹配,二义性调用
- 在函数内部进行重载的操作是一个不好的习惯,尽量避免.

## 6.5特殊用途

- 因为函数可以多次声明,因此可以在不同的声明中给函数添加参数默认值,但是要符合从后向前,且不能重复的规则.
- 当使用一个对象作为函数的默认值时,修改对应的对象也会修改函数的默认值.
- 当方法比较短时尽量使用inline对函数进行修饰,减少函数调用产生的开销.
- 使用constexpr 对可以在编译器计算值的方法进行修饰在编译时就完成计算.减少运行时开销.
- constexpr 修饰的函数允许返回非const变量,当使用constexpr修饰的函数传入的实参也是constexpr且可以在编译时完成计算则返回的也是constexpr表达式,反之则不然.
- 需要讲inline和constexpr修饰的函数放在头文件中,并且可以进行多次定义但是多次定义的方法体必须一致.

### 6.5.3 assert宏

- assert 在c++中是一中预处理宏,定义在cassert中
- 当assert(expr)中的表达式为真时不做操作,否则输出信息并终止程序.
- 当定义了NDUBG则assert什么都不做,
- #define NDUBG 即可关闭assert ,许多编译器也支持使用命令的方式定义NDBUB

## 6.6函数匹配

- 精确匹配优先于转换之后匹配

### 6.6.1实参类型转换

- 优先级
  - 1. 精确匹配(类型相同,数组转指针,添加或者去除顶层const)
    2. 通过const装换
    3. 类型提升
    4. 算数类型转化,指针转化
    5. 类类型转换

- 类型小于int的类型,在提升时会直接提升至int型

## 6.7函数指针

- 声明函数指针,使用指针替换方法名即可

- 讲函数名作为值使用时会自动转化为指针.

- 重载函数的函数指针类型必须和重载的某一个函数精确匹配

- 可以使用类型别名和decltype减少声明函数指针的代码

- 返回函数指针,可以使用decltype 和后置返回类型的方式,也可以适用类型别名

  - ```
    int (*func(int))(int*,int);
    auto func(int)->int (*)(int*,int);
    decltpye(size()) *func(int);
    ```

    