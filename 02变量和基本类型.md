# 变量和基本类型

## 2.1基本内置类型

### 2.1.2类型转化

#### 含有无符号类型的表达式

当一个有符号类型在无符号类型的右侧进行运算时，会先将右侧的有符号数转化为无符号数，对于符的有符号数转化为无符号数的过程类似于直接给无符号数赋给一个负值，结果就是这个复数加上无符号数的模。

### 2.1.3字面值常量

#### 整形和浮点型字面值

默认情况下十进制字面值是带符号数，而八进制和十六进制也可能是无符号的也可能是有符号的。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型的字面值。

#### 转义序列

泛化转义序列：\x 后紧跟一个或者多个十六进制数字 或者 \后紧跟1，2，3个八进制数组

#### 指定字面值类型

![字面值图像](E:\文档\note\cpp\img\2019020718075561.png)

```cpp
//宽字符型字面值，类型是wchar_t
 L'a';
 
//utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
 u8"hi!";
 
 //无符号整型字面值，类型为unsigned long long
 42ULL;

//单精度浮点型字面值，类型为float
 1E-3F;

//扩展精度浮点型字面值，类型为long double
 3.14159L；
```

## 2.2变量

### 2.2.1变量定义

变量定义的形式一般是：类型说明符 一个或者多个变量名组成的列表，变量名用逗号分割最后以分号结尾。

#### 初始值

当一个变量在创建时获得了一个特定的值，我们称这个变量被初始化了。当一次定义两个变量或者多个变量时，对象的名字随着定义也就马上可以使用了。

在c++中初始化与赋值是两个完全不同的操作。初始化时在创建变量时赋予其一个初值，赋值是擦除源值用一个新值替代。

#### 列表初始化

以下四种方式都可以实现定义一个int 类型的对象 a并初始化为0。

```cpp
int a=0;
int a={0};
int a{0};
int a(0);
```

使用花括号进行初始化的形式被称为列表初始化。

当我们使用列表初始化去初始化一个内置类型变量时，如果存在丢失信息的风险那么编译器将会报错。

```cpp
long double ld=3.1415926536;
int a{ld},b={ld};//错误： 转化未执行，因为存在丢失信息的风险
int c(ld),d=ld; //正确，但是存在信息丢失。
```

#### 默认初始化

如果定义时没有指定初始值，那么变量则会被默认初始化。此时变量被赋予的“默认值”变量类型来决定，同时变量定义的位置也会对变量的默认值产生影响。

定义在函数体外的内置类型会被默认初始化为0，定义在函数体内的内置类型则不会被初始化。

类对象如果没有显示的初始化那么会其值由具体类型决定，如果该类型支持无需显示初始化而定义对象那么就会提供一个默认值，如果类型要求必须显示初始化那么会出现错误。

### 2.2.2变量声明和定义的关系

声明试得名字为程序所知，定义负责创建与名字关联的实体。一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。（一个变量能且只能被定义一次，但是可以被多次声明，在函数体内部如果试图初始化一个由extern 关键字标记的变量，将引发错误。

变量声明规定了变量的类型和名字，定义除此之外还申请初始空间，也可能会给变量赋一个初始值。

如果向声明一个变量而非定义它，需要在变量名前添加关键字extern，且不显式的初始化变量。

### 2.2.3标识符

字母下划线数字组成，字母或者下划线开头。

自定义标识符你能连续出现两个下划线，不能以下划线紧跟大写字母开头，不能再函数体外定义下划线开头的标识符。

### 2.2.4作用域

c++中大多数作用域用花括号区分。定义再函数体之外的名字用于全局作用域，定义再花括号内部的称为块作用域。

#### 嵌套作用域

允许再内层作用域中重新定义再外层作用域中出现过的名字。如果想显示的指定使用外层的变量需要加上作用域的名字。:: 域操作符

## 2.3复合类型

基于其他类型定义的类型，c++中有几种复合类型，其中包括：引用和指针。

### 2.3.1引用

引用通俗的讲就是给一个变量取别名。通过讲声明符携程&d的形式来定义引用类型，其中d是声明的变量名。

```c++
ing ival = 1024;
int &refVal = ival;
int &refVal2;//错误引用必须被初始化
```

引用无法修改绑定的对象，因此定义必须初始化。因为引用本身不是一个对象所以无法定义引用的引用。

引用的类型要与绑定的类型严格匹配，并且不能与字面值或者某个算式的结果进行绑定。

### 2.3.2指针

指针 本身是一个指向指定类型的对象。可以在生命周期内指向几个不同的对象，无需再定义时赋初值。

#### 获取对象的地址

指针用来存放某个对象的地址，可以使用&取地址符来获取指定对象的地址。

#### 利用指针访问对象

如果一个指针指向一个对象可以使用解引用符*来访问改对象。

#### 空指针

```cpp
int *p = nullptr;
int *p1 = 0;
int *p2 = NULL;
```

nullptr 是c++1引入的一种方法， nullptr是一种特殊类型的字面值，可以被转化为任意类型的指针。

#### void*指针

void* 指针是一种特殊的指针，可以**指向任意类型的对象**。

### 2.3.3理解符合类型的声明

#### 定义多个变量

定义一个引用或者一个指针的方式有两种，一种是讲* 或者& 与变量名紧紧相连，另一种是讲*或者& 跟在类型之后。

```cpp
int* a,p;//a 是指针，p是一个int变量
```

#### 指向指针的指针

```cpp
int a=10;
int *p = &a;
int **p2 = &p;//指向p的指针
```

#### 指向指针的引用

引用本身不是一个对象因此不能定义指向一个定义的指针。但是指针是对象，因此能够存在对指针的引用。

```cpp
int i = 42;
int *p;
int *&r = p;//p的一个别名 r
r = &i;
*r=0;
```

理解r的类型到底是什么可以从左向右阅读r的定义。

## 2.4const 限定符

使用const限定的变量的值不可以进行修改。

#### 默认情况下const对象仅在文件内有效

当编译时以初始化的方式定义一个const对象是，编译器将会再编译过程中把用到该值的地方都替换为对应的值（类似于预处理器做的#define替换，但是会进行类型检查）。

因为为了执行替换，编译器必须知道变量的初始值。因此const对象通常被设定为尽在文件内有效。当多个文件中出现了同名的const变量时，等于再不同的文件中分别定义了独立的变量。

为了实现再不同文件中共享同一个const 变量的操作，需要*对所有使用到该const的定义和声明地方都加上extren关键字限定*。（一次定义多次声明）

### 2.4.1const的引用

将引用绑定到const对象上，被称为对常量的引用。常量引用是对const的引用。**对const的引用可能引用一个非const的对象**。

#### 初始化和对const的引用

初始化常量引用时允许使用任意表达式作为初始值，只要能够转换成引用的类型即可。

允许将一个常量引用绑定到***非常量的对象***，***字面值***甚至是一个***表达式***

当出现上述的绑定时编译器会生成一个临时变量，进行转化或者存储临时值，然后将常量引用与临时对象进行绑定。

### 2.4.2指针和const

**指向常量的指针**不能用于改变其指向对象的值。

#### const指针

允许将指针定义为一个常量，**常量指针**必须初始化，且一旦被初始化就不能再改变。

将const放在*之前即声明该指针是一个常量。该指针的指向不能修改，但是它指向的对象的值不一定不能修改。（从右向左阅读定义）

### 2.4.3顶层const

**顶层const**是指指针本身是一个常量，**底层const**是指指针指向的对象是一个常量。

当执行拷贝操作时，顶层const不受什么影响。底层const的限制却不能忽视，一般来讲非常量可以转常量反之则不可以。

### 2.4.4constexpr表达式

**常量表达式（const expression）**指值不会改变且再编译时就能得到计算结果的表达式。



```cpp
const int sz = get_size(); //sz 是常量，但是它的值只有等到运行时才能获得 ，所以不是const expresssion
int staff_size = 27;//不是，因为staff_size不是 const类型
const int max_files = 20;//常量表达式
const int limit = max_files+1;//常量表达式
```

#### constexpr变量

**c++11新标准**规定允许讲类型声明为***constexpr***类型，以便由编译器来检查变量的值是否为常量表达式。

声明为constexpr的变量一定是常量，且必须用常量表达式初始化。不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的**constexpr函数**，这种函数应该足够简单使再编译时就计算其结果。

#### 字面值类型

声明constexpr用到的类型一般称为字面值类型。**算术类型，指针，引用**都属于字面值类型。自定义的类不属于字面值类型。

一个constexpr类型的指针的初值必须是**nullptr**或者是**0**，或者是**存储与某个固定地址中的对象**。

函数体内的变量一般并非存在固定地址中，定义与所有函数体之外的对象其地址固定不变。

#### 指针和constexpr



```cpp
const int*p = nullptr;//一个指针指向整型常量
constexpr int* q = nullptr;//一个指向整数的常量指针
```

constexpr把它定义的对象置为了顶层const。

## 2.5处理类型

### 2.5.1类型别名

**类型别名**是一个*名字*，它是某种类型的*同义词* 

两种定义类型名的方式：

- typedef

  ```cpp
  typedef double wages;//wages 是double的同义词
  typedef wages base, *p;//base是double的同义词，p是*double的同义词。
  ```

  其中typedef作为**基本数据类型**出现 类似与int a =0; 中的int。但是它定义的不是变量而是类型别名。与普通的声明语句一样他，这里的声明也**可以包含限类型修饰符**，也可以有基本数据类型**构造出复合类型**。

- 别名声明（alias declaration）

  ```cpp
  using SI = Sales_items;
  ```

#### 指针、常量和类型别名

```
typedef char *pstring;
const pstring cstr = 0;//cstr是指向char的常量指针
const pstring *ps;//ps是一个指针他的对象是指向char的常量指针。
```

需要将pstring 看作一个整体去理解，第二句中的const修饰的是指向char*的的指针，因此cstring是一个常量指针。

### 2.5.2auto类型说明符

***c++ 11***引入**auto**类型说明符用它能够让编译器去替我们分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，因此auto类型必须有初值。

#### 复合类型、常量和auto

当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器会使用引用对象的类型作为auto的类型。

```cpp
int i = 0 ,&r =i;
auto a = r;//a是一个整数
```

auto一般会忽略掉顶层的const，但是底层的const则会被保留下来。

```cpp
const int ci = i , &cr = ci;
auto b = ci;//b是一个int 值
auto c = cr;//c是一个整数
auto d = &i;//d是一个指向整型的指针
auto e = &ci;//e是一个指向常量整型的指针
```

如果希望推出的类型是顶层const需要显示的指定

```cpp
const auto f= ci;//常量整型
```

还可以将auto的类型设置为引用，将auto类型设置为引用时初始值中的顶层常量属性仍然保留。

```cpp
auto &g=ci;//常量整型的引用。
auto &h = 42;//错误无法为非常量型变量绑定字面值
const auto &j = 42;//指向常量的引用。
```

当auto声明多个变量时需要保证类型的一致性。

```cpp
auto &n = i,*p2=&ci;//错误因为i的类型为int 而&ci的类型为const int
```

### 2.5.3decltype类型指示符

***c++11***中引入了了第二种类型说明符***decltype***，就可以从表达式得类型推断出要定义变量的类型，但是不用该表达式的值初始化变量。在此过程中编译器分析表达式的类型，但是并不进行实际得计算。

如果**decltype**使用得表达式是一个变量，则decltype返回该变量得类型，包括顶层const和引用。

#### decltype和引用

一些表达式将向decltype 返回一个引用类型，这通常意味着该表达式得结果能够作为一个赋值语句的左值。

```cpp
int i= 42，*p=&i,&r=i;
decltype(r+0) b;//int ，当不想让结果是引用时可以将r作为表达式的一部分
decltype(*p) c;//错误 c是int&  必须初始化 解引用返回的是引用类型，因为解引用可以作为赋值语句的左值。
decltype((i)) d;//错误 d是int&
decltype(i) e;//正确
```

如果decltype的表达式是加了一个括号的变量则对应的类型必为引用

## 2.6自定义类型

结构体：

```
struct typeName{
	std::string bookNo;
	unsingned units_sold=0;
	double revenue =0.0;
};
```

记住再定义之后加分号；

***c++11***新标准可以为数据成员提供一个类内初始值。没有初始值的成员见会被默认初始化。只能使用花括号，不能使用圆括号。

### 2.6.3编写自己的头文件

类的定义，通常放在头文件中，只能被定义一次的实体通常放在头文件中，例如类 const 和constexpr变量。

#### 预处理器

再编译程序之前执行的一段程序，可以确保头文件被多次包含仍能安全工作。

预处理器会将#include 的内容替换为指定头文件。

***头文件保护符***预处理器的一个功能，依赖于预处理变量。

预处理变量有两种状态：已定义和未定义，

*#define* 把一个名字设定为预定义变量，#ifdef 当且仅当变量已定义时为真，*#ifndef*当且仅当变量未定义时为真。一旦检车结果时真则会执行后续操作直到遇到*#endif*指令

预处理变量无视c++语言中关于作用域的规则



