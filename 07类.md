## 7.1定义抽象数据类型

### 7.1.4构造函数

- 构造函数不能为const,构造函数与类别名相同,且没有返回值.

- 默认构造参数,不包含任何参数的构造方法.

- 编译器创建的构造函数称为合成的默认构造函数. 当成员函数有类内初值用该值初始化,否则使用默认初始化方法.

  - 当成员变量中包含没有默认构造方法的类型且没有被类内初始化时,编译器无法合成默认构造函数

- 当我们希望显示的让编译器帮我们合成一个默认构造方法时,可以在声明后添加=default,如果default出现在类内默认构造函数为内联,如果在类外部,默认不是内联.

- 构造函数初始化列表中如果没有对所有的成员函数进行初始化,剩余的成员变量将会以默认构造函数相同的方式进行初始化.

  

- 当没有在构造函数的初始化列表中显示的初始化成员,则会在构造函数体调用之前执行默认初始化.

- 对于const成员函数只能在初始化列表中进行初始化

- 成员变量初始化的顺序取决于在类中定义的顺序,而与初始化列表的顺序无关

## 7.2访问控制与封装

- 友元函数与友元类,只能在类内部声明,且在前边加上friend关键字
- 为了使用户能够正常访问友元函数,还需要在类外再次声明友元函数

## 7.3类的其他特性

- 类内可以定义类型成员:

  - ```cpp
    class Screen{
        public:
    		typedef std::string::size_type pos;
    	private:
    		pos cursor =0;    
    }
    //可以通过这样的方式隐藏实现细节
    
    ```

- 类内定义的方法默认为inline函数

- mutable关键字,用于表示改变量是可变数据成员.它永远不会是const
- 可以通过成员函数是否为const 重载成员函数
- 对与公共代码应该使用私有功能函数实现
- 类也可以先声明但是不定义,这种成为不完全类型,只能在非常有限的场景下使用.
- 类之间的友元关系,可以使友元类访问内部的所有成员,友元不具有传递性.
- 也可以另其他类的成员函数作为自己的友元函数.
- 友元函数的声明作用只是影响访问权限,并不是真正意义上的声明.

## 7.4类的作用域

- 一个类就是一个作用域块,所以定义函数是需要声明类名
- 名字查找
  - 1. 在块内查找其声明语句,只考虑在名字的使用前出现的声明
    2. 如果没有找到,继续查找外层作用域
    3. 没有找到报错
- 类的定义分两步处理,首先编译成员声明,当类的全部可见之后在编译函数体,因此在编译函数体时所有的类内成员是可见的状态,
- 当类内没有找到声明是尝试在类外查找声明.
- 一般来说内层作用域可以重新定义内层作用域中的名字即使该名字已经在内层作用域中使用过,在类内如果使用了域外的某个类型名,则不能在之后重新定义该类型名

